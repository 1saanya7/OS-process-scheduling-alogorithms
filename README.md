# OS-process-scheduling-alogorithms
An implementation of various CPU scheduling algorithms in C++. The algorithms included are First Come First Serve (FCFS), Round Robin (RR), Shortest Job First (SJF), Shortest Remaining Time (SRT), Shortest Job First with Different arrival Time(SFF), Bankers Algorithm

First Come First Served (FCFS): It is a scheduling algorithm in which the process that arrives first is executed first. It is a simple and easy-to-understand algorithm, but it can lead to poor performance if there are processes with long burst times. This algorithm does not have any mechanism for prioritizing processes, so it is considered a non-preemptive algorithm. In FCFS scheduling, the process that arrives first is executed first, regardless of its burst time or priority. This can lead to poor performance, as longer running processes will block shorter ones from being executed. It is commonly used in batch systems where the order of the processes is important.

Round Robin with varying time quantum (RR):
->Round Robin (RR) with variable quantum is a scheduling algorithm that uses a time-sharing approach to divide CPU time among processes. In this version of RR, the quantum (time slice) is not fixed and can be adjusted depending on the requirements of the processes. This allows processes with shorter burst times to be given smaller quanta and vice versa.

->The algorithm works by maintaining a queue of processes, where each process is given a quantum of time to execute on the CPU. When a process's quantum expires, it is moved to the back of the queue, and the next process in the queue is given a quantum of time to execute.

->The variable quantum allows the algorithm to be more efficient as it allows the CPU to spend more time on shorter processes and less time on longer ones. This can help to minimize the average waiting time for processes. Additionally, it also helps to avoid the issue of starvation, which occurs when a process with a long burst time prevents other processes from executing.

Shortest Job First:It is a process scheduling method that selects the process with the smallest burst time for execution next. In this provided C++ implementation, an array of structures is used to store process details such as arrival time, burst time, and other relevant times. The program first initializes these details for each process. During execution, it keeps track of the remaining burst times and completion statuses of processes. At each time unit, the algorithm selects the process that has arrived and has the smallest burst time. If two processes have the same burst time, it selects the one that arrived earlier. The selected process runs for one time unit, decrementing its remaining burst time. Once a processâ€™s burst time reaches zero, it is marked as completed, and its completion, turnaround, and waiting times are calculated. This continues until all processes are completed. The results are then displayed in a table format, showing the completion, turnaround, and waiting times for each process. This non-preemptive version of SJF ensures that once a process starts execution, it runs to completion before the next process is selected.

Banker's Algorithm: It is a resource allocation and deadlock avoidance algorithm used in operating systems to manage resources among competing processes. This algorithm ensures that a system remains in a safe state by making an "allocation matrix" that represents the current allocation of resources to each process and a "maximum requirement matrix" that represents the maximum resources each process may need. The code provided follows the steps of the Banker's Algorithm: it first takes user inputs for the number of resources and processes, then constructs the allocation and maximum requirement matrices. It calculates the remaining needs for each process and the currently available resources. Using these, it iteratively checks whether the system can allocate resources to each process without leading to a deadlock. It marks processes that can be safely allocated resources, updating available resources and the safe sequence of process execution. If it finds a sequence where all processes can complete, it prints this sequence as a "safe state"; otherwise, it indicates that no safe state exists, meaning potential for deadlock.
